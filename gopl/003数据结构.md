# 数据结构

内置数据类型的设计要考虑两方面：
- 硬件特性
- 表达复杂数据结构的便捷性

go的数据结构分4类：
- 基础类型 eg：数字 字符串 bool型
- 复合类型 eg：数组 结构体
- 引用类型 eg：指针 切片 字典 函数 通道
- 接口类型 eg：接口

## 数字之整形

类型 | 类型 | 位数 | 字节
-- | -- | -- | --  
int8 | uint8 | 8bit | 1byte
int16 | uint16 | 16bit | 2byte
int32 | uint32 | 32bit | 4byte
int64 | uint64 | 64bit | 8byte

int和unit依据平台位数来决定，64位对应int64,32位对应int32

rune unicode字符，和int32等价； byte和int8等价

uintptr用于存储指针，只有在底层编程才会用到，eg：go和c互调，
位数并不确定。

二元算术运算的5种优先级：
- 乘除 取模 左移 右移 按位与& 按位置0:&^
- 加减 按位或| 按位异或^
- 比较运算 等于 不等于 大于 小于 等
- 逻辑运算&&
- 逻辑运算||

```go
fmt.Printf("%[1]v, %[2]v", a, b) // []表示使用第几个操作数(参数)来对应

// % d, %和d之间如果有空格，打印的时候会在前面打印一个空格

for i:=0; i < len(字符串); i++  {} // 字符串[i] 的类型是byte，uint8
for _, x := range 字符串 {} // x类型是rune，int32
```
基本字符(可见+不可见)常见的就是0-255之内的，用1byte表示即可，
unicode，用1-4个byte表示，支持中日韩文字，
常规for时，是按字节遍历；for range时，是按unicode字符遍历

for range 遇到中文，索引不是连续的，会出现跳跃的情况,
如果要计算字符串的字符有多少个，可用utf8.RuneCountInString(),
或者使用 n:=0; for range str {n++}获得

## 数字之浮点型

float32 提供9位精度，包括小数点  
float64 提供18位精度，包括小数点， 她们都会自动做四舍五入

太大的数或太小的数最好用指数方式表示

## 数字之复数

x := 1 + 3i

## 布尔型

## 字符串

字符串不可修改，底层应该和数组的实现类似，这让复制的代价变低

- ""包含的字面量，里面可以有转义
- 反引号包含的字面量，原生字面量，里面不会进行转义，写正则表达式时会用到、html模板、json字面值、命令行信息、多行的场景

标准库提供了4个包来处理字符串：
- bytes
- strings
- strconv
- unicode

进制转换，输出字符串时，使用fmt.Sprintf比strconv.Format更方便一些,
将字符串解析为整数，用strconv更方便，特别是转成uint，

## 常量

批量声明时，第一个常量的初始化表达式不能省略，其他都可省略，
如果省略了，就使用前面常量初始化表达式写法，注意 只是写法继承了，字面量也继承了，
如果遇到iota，表达式写法也是一样的。

iota，常量生成器，在第一次出现时，为0，后面遇到的每一行，加1，
遇到新的iota，则重置为0

无类型常量的好处：
- 更高的精度
- 无需显式类型转换而可以应用于更多表达式

无类型常量在表达式计算中，会隐式转换成相应的类型

## 复合类型之数组

数组初始化时，var abc[...]int = [1]int{1}, ...表示根据初始化的值的个数来确定

- 数组的长度需要在编译器确定下来
- 数组作为函数参数时，不是引用，而是副本，这和c/c++是不一样的
- 数组的长度是类型的一部分，是不能更改的，所以没没法删除其中一些值

```go
    var a[...]int = [1]{1}
    b := [...]int{10:123}  // 数组有10个元素，最后一个是123
```

## 复合类型之结构体

结构体每个成员变量都是确定的，底层不会变动，所以可以取址

结构体成员的顺序也很重要，不同顺序就是不同的结构体类型

和其他语言一样，结构体里不能包含自身，也就是不能嵌套，但可以有指针指向同类型的结构体变量

空结构体也是有应用场景的：map模拟set时: make(map[string]struct{}) 只强调key的作用。

结构体成员名如果是大写，就是可导出的，如果是小写，在其他包就访问不到

结构体嵌套，匿名成员,好处是不用写太多嵌套。
结构体字面量不能使用匿名成员语法。
匿名成员还有个特点：普通成员名大写才能导出；
如果是匿名成员，不管大小写，都能以简短形式访问匿名成员的嵌套成员,
这句话适应条件是包内，说白了，还是下面一条：
包外能访问的必须是大写，包内不管大小写都是能访问的。


fmt.Printf("%#v") 中间的#副词的作用是打印每个成员的名字

go针对oop的封装，落地在struct上，

## 引用类型之切片

底层还是使用数组，相对数组来说，增加了很多灵活性的功能

slice由3部分组成：
- 指针 指向第一个slice元素对应底层数组元素的地址
- 长度 slice元素个数
- 容量 slice的开始位置到底层数据的结尾位置，长度超过这个值就需要重新申请数组了

## 引用类型之map

map 底层用的是hash

map中的元素是k-v对，并不是一个变量，所以不能对map的元素进行取址操作。

另一个原因是go中的数据结构的底层，可能都会随着元素数量增长而重新分配更大的，
重新分配，取值就没意义了。在使用过程中，像slice、map这种就不关心具体的内存了，
而像数组里存的元素就是变量，就可以使用取址。
go比较聪明的将数组和数组长度绑定到一个类型中，这样就不存在数组扩容遇到取址的问题。

map里面的迭代顺序是不确定的，这时go故意这么实现的，因为哈希函数会导致迭代顺序变换，
要兼顾不同的哈希函数，可能要做很多工作，索性弄成随机，go也少做一点事，
开发者开发业务逻辑也不用依赖map的迭代顺序。

一个未初始化的map变量的值是nil，除了增改会报异常，其他操作都可以

```go
    // 判断map里是否有某个值
    if v, ok := myMap["k"]; !ok {
        xxx
    }
```

map可以和nil比较，map和map是不能比较的，类似的还有slice

go中没有set类型，map可以完成set的功能，因为go中的key是不一样的。
c++中就有multimap multiset，go中就简单很多，map就够了。

map的key要能进行比较，slice作为map的key肯定是不行的，但也有其他解决方法：
- 添加辅助函数，将slice转换成string

惰性初始化：像map、slice等，到了实际使用时才调make进行初始化。

map虽然非常灵活，在部分场景使用数组会更加高效，eg：整数集合 求并集 求差集

## 引用类型之函数

```go
    func abc(a, _ int){}  // _表示第二个参数未使用到
```

- 如果两个函数的形参和返回列表中的变量类型一一对应，就称两函数有相同类型和标识符
- go中的函数参数没有默认值

对于错误的处理一般有5种处理策略:
- 传播错误，直到某个函数来处理，意味某个子程序失败了。比较常用
- 重试，限制重试时间间隔、次数。适用于偶发性错误
- 输出错误信息，并结束程序。适用于程序无法继续运行时，一般多用于main函数
- 只提供错误信息。适用于无需中断程序的情况
- 忽略。适用于不影响程序逻辑和运行的情况。eg：删除临时目录中的文件失败时。

- 函数是go中的第一类值，和变量一样，可以赋值。可以和nil比较，不能和其他函数值比较
- 函数不能作为map的key值
- 函数可以作为另一个函数的参数，这样可以将逻辑和数据进行分离

    fmt.Printf("%*s", 5, "abc") // '*' 表示在字符串之前填充5个空格

匿名函数：
- 有名字的函数只能出现在包级申明
- 匿名函数的好处是：可以访问外部函数完整的词法环境(就是说可以访问外部函数里的变量)
- 匿名函数可以实现闭包场景

for循环的迭代因子变量，如果将迭代因子变量用于匿名函数，
匿名函数用到的是迭代因子变量的内存地址，说白了就是引用，而不是具体值，
如果for中有匿名函数，函数中又用到了迭代因子，那么实现和逻辑有很大差异：
如果匿名函数在for循环外面执行，那么她们使用到的迭代因子都是最后一个迭代因子。

为什么？
因为匿名函数都会在循环结束后，再确定函数值。

延时函数 defer ：
- defer func("123")() 后面的()不要忘记，这样可以将延时函数分成两部分：
  - 执行部分立马执行
  - 返回部分在外部函数结束时执行
- defer func("123") 后面如果没有(),执行部分会在外部函数结束时执行，返回部分不会执行
上面两点只适用于：
```go
    func abc() func() {
        start := time.Now()
        return func() {
            log.Printf("%s", time.Since(start))
        }
    }

    func main() {
        defer abc()() // 正确姿势
    }
```

延时函数 + 匿名函数的能量：
- 延时函数会在"外部函数执行return语句更新了返回值"之后再执行，所以延时函数可以修改返回值
- 程序发先panic异常时，会毅力中断运行，并执行当前协程上的defer函数，知乎输出崩溃日志

## 方法

- 接收器只能出现类型或指向她们的指针
- 如果类型本身就是一个指针，那么她不能出现在接收器中，是为了避免歧义
- 无法通过一个无法取到地址的接收器来调用指针方法 eg：临时变量的内存地址就无法取到

```go
    Point{1,2}.Scale(2)  // Scale方法的接收器是指针，那这种写法就是不对的
```

- nil也能作为接收器，只需要在类型说明处，说明nil表示的什么意思即可
- 函数有函数值，方法也有方法值。函数值就是函数变量；方法值包含了接收者和特定的函数，是选择器的返回。
- 函数值可以作为变量，使用在函数参数中；方法值也是类似的
- 还可以弄成一个方法表达式，将 类型.方法 保存在函数值里，调用形式：函数值(接收者,参数)

```go
    func (s *IntSet) String() string {} // 接收者是指针
    fmt.Println(&x) // 正确的使用方式，会自动找到String方法
    fmt.Println(x.String()) // 正确，直接调用了String(),并打印返回值
    fmt.Println(x) // 错误，因为没有IntSet的 String，所以会按原始的方式打印
```

## 类型

- 类型中可以嵌套匿名字段，eg：结构体体嵌套其他类型
- 类型中嵌套的匿名字段也可能是一个命名类型的指针，好处是可以共享通用结构，并动态改变对象之间的关系


## 引用类型之通道

是go中并发的基石，支持一个现代的并发编程模型CSP

    CSP：communicating sequential processes 顺序进程通信。

通道是各个协程之间的通信机制，可以用make创建，也是一个引用类型

通道是可以做比较的，也可以和nil比较

- channel支持两个操作：发送 接受
- channel还支持关闭，close，关闭之后 就是nil值了
- 对于nil channel进行发送操作，会导致panic
- 对于nil channel进行接受操作，是ok的，会读取之前已经成功发送的数据
- 多个通道将多个协程串联起来，称为pipeline管道

```go
    func abc(a chan<- int, b <-chan int)  // a表示只发送通道，b表示只接受通道，都是单向通道
```
单向通道的限制只在编译器做检查

select 多路复用，每一个case表示一个通信操作

